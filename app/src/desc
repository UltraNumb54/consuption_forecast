# Energy Consumption Forecasting Pipeline

Этот репозиторий содержит пайплайн для прогнозирования почасового потребления электроэнергии на 1-3 дня вперед.

## Требования

*   Python 3.x
*   pip
*   (Опционально) Virtual environment (например, `venv`)

## Установка

1.  Клонируйте репозиторий:
    ```bash
    git clone <ваш_URL_репозитория>
    cd energy_forecasting_pipeline
    ```
2.  (Рекомендуется) Создайте виртуальное окружение:
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```
3.  Установите зависимости:
    ```bash
    pip install -r requirements.txt
    ```

## Использование

### Подготовка данных

Поместите ваши исходные файлы данных в папку `data/raw/`:
*   `consumption_data.csv`
*   `weather_data.csv`
*   `russian_production_calendar_2017_2025.csv`

**ВАЖНО:** Убедитесь, что форматы файлов соответствуют ожидаемым (как описано в `src/data_ingestion.py` или `src/preprocess.py`).

### Запуск пайплайна

Для запуска полного пайплайна (предобработка -> обучение -> прогнозирование) выполните:

```bash
python pipeline_runner.py

Этот скрипт:

Загрузит и проверит исходные данные.
Выполнит предобработку и объединение.
(Пере)обучит модель на обновленном датасете и сравнит с текущей лучшей.
Сохранит лучшую модель в models/latest_model.cbm.
Сгенерирует прогнозы на основе последних данных и сохранит их в data/predictions/.
Выведет логи в консоль и в папку logs/.
Планирование (например, с помощью cron)

Структура проекта
src/: Основные скрипты.
data_ingestion.py: Загружает и проверяет исходные данные.
preprocess.py: Объединяет, очищает и создает признаки.
model_training.py: Обучает модель CatBoostRegressor и управляет версиями.
model_serving.py: Загружает модель и делает прогнозы.
utils.py: Вспомогательные функции (логирование, оценка).
models/: Обученные модели.
data/: Входные, промежуточные и выходные данные.
raw/: Исходные файлы.
processed/: Обработанные датасеты.
predictions/: Результаты прогноза.
logs/: Логи выполнения.
pipeline_runner.py: Основной скрипт, orchestrating пайплайн.

 Вот краткий обзор созданных файлов:

src/data_ingestion.py: Скрипт для загрузки и базовой проверки трёх исходных файлов данных (consumption_data.csv, weather_data.csv, russian_production_calendar_2017_2025.csv).
src/preprocess.py: Скрипт, объединяющий логику из preproccesing.py и final_preproccesing.py. Он обрабатывает каждый датасет, объединяет их, создаёт признаки (лаги, скользящие средние, циклические и др.), обрабатывает пропуски и фильтрует данные по качеству.
src/model_training.py: Скрипт, отвечающий за обучение модели CatBoostRegressor на обработанном датасете. Включает логику сравнения новой модели с текущей лучшей и сохранения только лучшей версии.
src/model_serving.py: Скрипт для загрузки сохранённой лучшей модели и генерации прогнозов на основе новых признаков.
pipeline_runner.py: Главный скрипт, который orchestrates (координирует) весь пайплайн: загрузка -> предобработка -> обучение -> сохранение/сравнение -> генерация прогноза.
README.md: Инструкция по использованию пайплайна, включая установку, запуск и планирование.

# Формат данных и минимальный период для проекта прогноза потребления

## Общие требования

*   **Кодировка файлов:** UTF-8.
*   **Разделитель в CSV:** Точка с запятой (`;`).
*   **Папка для входных данных:** `data/raw/` (относительно корня проекта).
*   **Названия файлов:** Должны точно соответствовать:
    *   `consumption_data.csv`
    *   `weather_data.csv`
    *   `russian_production_calendar_2017_2025.csv`

## Форматы файлов

### 1. `consumption_data.csv` (Потребление)

*   **Описание:** Почасовые данные потребления электроэнергии.
*   **Структура:**
    *   **Строка 1:** Заголовок (названия столбцов).
    *   **Строка 2 и далее:** Данные.
*   **Колонки (в указанном порядке, разделитель `;`):**
    *   `date`: Дата в формате `ГГГГ-ММ-ДД` (например, `2025-09-22`).
    *   `hour`: Час в 24-часовом формате (целое число от 0 до 23).
    *   `consumption`: Потребление энергии (десятичное число, разделитель - запятая, например, `777,777`).
    *   `week_day`: День недели (целое число, например, `7` для воскресенья, но точное значение не используется в текущем коде).
    *   `temperature`: Температура воздуха в градусах Цельсия (десятичное число, разделитель - запятая, например, `-16,5`).
    *   `temperature_forecast`: (Опционально) Прогноз температуры. *В текущей реализации этот столбец удаляется при предобработке.*
*   **Пример строки:**
    ```
    date;hour;consumption;week_day;temperature;temperature_forecast
    2025-09-22;14;340,500;7;-16,5;0,0
    ```
    *(В коде предполагается, что `temperature_forecast` может отсутствовать или быть не для всех часов)*

### 2. `weather_data.csv` (Погода)

*   **Описание:** Архив погодных данных.
*   **Структура:**
    *   **Строки 1-5 (примерно):** Комментарии (начинаются с `#`).
    *   **Одна из строк до данных:** Строка с названиями столбцов, начинающаяся с `"` (например, `"Местное время в ..."`).
    *   **Строки после заголовка:** Данные.
*   **Колонки (в указанном порядке, разделитель `;`):** Пайплайн ожидает, что первые 13 столбцов будут содержать: `datetime`, `T`, `P0`, `P`, `U`, `DD`, `Ff`, `ff10`, `WW`, `W'W'`, `c`, `VV`, `Td`. Однако **используются только столбцы `datetime`, `U` (влажность) и `Ff` (скорость ветра)**. Столбец `T` (температура) *не используется* моделью, но должен присутствовать в файле для корректного парсинга.
*   **Колонка `datetime`:** Дата и время в формате `ДД.ММ.ГГГГ ЧЧ:ММ` (например, `22.09.2025 10:00`).
*   **Колонка `U`:** Влажность воздуха (целое число, например, `100`).
*   **Колонка `Ff`:** Скорость ветра (десятичное число, например, `4` или `5.0`).
*   **Пример начала файла:**
    ```
    # Метеостанция ...
    # Кодировка: UTF-8
    # ...
    "Местное время в ...";"T";"P0";"P";"U";"DD";"Ff";"ff10";"WW";"W'W'";"c";"VV";"Td";
    "22.09.2025 10:00";"12.0";"739.5";"741.2";"100";"Ветер, дующий с юга";"4";"";"...";"";"...";"4.4";"12.0";
    "22.09.2025 09:30";"12.0";"740.2";"741.9";"100";"Ветер, дующий с юга";"5";"";"...";"";"...";"8.0";"12.0";
    ```

### 3. `russian_production_calendar_2017_2025.csv` (Календарь)

*   **Описание:** Производственный календарь, указывающий, является ли день рабочим или нет.
*   **Структура:**
    *   **Строка 1:** Заголовок (названия столбцов).
    *   **Строка 2 и далее:** Данные.
*   **Колонки (в указанном порядке, разделитель `,`):**
    *   `date`: Дата в формате `ГГГГ-ММ-ДД` (например, `2025-01-01`).
    *   `day_type`: Тип дня. Возможные значения:
        *   `working day`: Обычный рабочий день.
        *   `weekend`: Обычный выходной (суббота, воскресенье).
        *   `non-working holiday`: Праздничный день (включая перенесённые).
        *   `working weekend`: Рабочий день в выходной (например, суббота перед 8 марта).
*   **Пример строки:**
    ```
    date,day_type
    2025-01-01,non-working holiday
    2025-01-02,non-working holiday
    2025-01-06,non-working holiday
    2025-01-07,non-working holiday
    2025-01-08,non-working holiday
    2025-01-09,working day
    ```

## Минимальный требуемый период данных

*   **Потребление (`consumption_data.csv`):** Пайплайн использует исторические данные для создания лаговых и скользящих признаков. Максимальный лаг в коде равен 168 (часов = 7 дней). Поэтому **для корректной генерации признаков и обучения модели необходимо как минимум 7 дней + 1 час** (для самого первого лага) = **170 часов** (примерно 7 дней и 2 часа) непрерывных данных. Однако, для стабильности и получения более репрезентативной модели, рекомендуется использовать **как минимум несколько месяцев** данных, а лучше — **несколько лет**, как в исходных данных.
*   **Погода (`weather_data.csv`):** Должна покрывать период, указанный в `consumption_data.csv`. Для создания признаков, как минимум, должны быть доступны `U` (влажность) и `Ff` (ветер).
*   **Календарь (`russian_production_calendar_2017_2025.csv`):** Должен включать все даты, присутствующие в `consumption_data.csv`.

**Вывод:** Минимально *технически* возможный период — 170 часов (чуть больше 7 дней) данных потребления с соответствующими погодными и календарными данными. Однако для получения *качественной* модели, требуемый период — **значительно больше**, например, **несколько лет**, как в вашем исходном датасете.

  
