1. Архитектура и принципы продакшн-пайплайна

Цель: сделать систему, которая будет регулярно получать новые данные, переобучать модель, делать прогнозы и, возможно, оценивать качество.

Входные данные: три исходных файла (consumption_data.csv, weather_data.csv, russian_production_calendar_...csv).
Выходные данные: Прогнозы на 1-3 дня вперед (например, в CSV или через API).
Принцип: Автоматизировать процесс от предобработки до генерации прогноза. Использовать CI/CD (Continuous Integration/Continuous Deployment) или планировщик задач (cron/scheduler).
2. Как часто переобучать модель?

Это зависит от нескольких факторов:

Частота поступления новых данных: Если вы получаете данные потребления и погоды ежедневно/ежечасно, то переобучение раз в день/неделю может быть оправдано.
Стабильность паттернов: Если поведение потребителей или погодные паттерны могут резко меняться, частое переобучение помогает адаптироваться.
Требования к точности: Более частое переобучение может улучшить точность на краткосрочной перспективе.
Вычислительные ресурсы: Переобучение требует времени и мощностей.
Рекомендации:

Ежедневно: Обычно хороший баланс между актуальностью и ресурсами. Можно обучать модель ночью на данных предыдущего дня.
Еженедельно: Если дневное переобучение слишком затратно, недельное может быть компромиссом.
По триггеру: Менее распространено, но можно реализовать мониторинг качества (см. ниже) и переобучать, если точность падает ниже порога.
Сравнение моделей: При каждом запуске можно обучать новую модель на расширенном датасете и сравнивать её с текущей продакшн-моделью на последнем куске данных. Если новая модель лучше, заменить текущую.


Пайплайн как один скрипт или через планировщик. Всё должно быть в одном репозитории/папке, с четкой структурой:
energy_forecasting_pipeline/
├── src/
│   ├── data_ingestion.py       # Загрузка новых данных (новый компонент)
│   ├── preprocess.py           # Ваш код из preproccesing.py + final_preproccesing.py
│   ├── model_training.py       # Ваш текущий model_training.py (может потребоваться небольшая адаптация)
│   ├── model_serving.py        # Скрипт/функция для загрузки модели и генерации прогноза (новый компонент)
│   └── utils.py                # Вспомогательные функции (например, оценка, логирование)
├── models/
│   ├── latest_model.cbm        # Хранение текущей лучшей модели
│   └── ...                     # Предыдущие версии моделей (опционально)
├── data/
│   ├── raw/                    # Папка для новых входных данных (consumption, weather, calendar)
│   ├── processed/              # Папка для промежуточных и финальных обработанных датасетов
│   └── predictions/            # Папка для результатов прогноза
├── logs/                       # Папка для логов выполнения пайплайна
├── requirements.txt            # Список зависимостей (pandas, numpy, catboost, ...)
├── pipeline_runner.py          # Главный скрипт, вызывающий все этапы подряд
└── README.md                   # Инструкция по использованию (см. п. 4)

# Energy Consumption Forecasting Pipeline

Этот репозиторий содержит пайплайн для прогнозирования почасового потребления электроэнергии на 1-3 дня вперед.

## Требования

*   Python 3.x
*   pip
*   (Опционально) Virtual environment (например, `venv`)

## Установка

1.  Клонируйте репозиторий:
    ```bash
    git clone <ваш_URL_репозитория>
    cd energy_forecasting_pipeline
    ```
2.  (Рекомендуется) Создайте виртуальное окружение:
    ```bash
    python -m venv venv
    source venv/bin/activate  # On Windows: venv\Scripts\activate
    ```
3.  Установите зависимости:
    ```bash
    pip install -r requirements.txt
    ```

## Использование

### Подготовка данных

Поместите ваши исходные файлы данных в папку `data/raw/`:
*   `consumption_data.csv`
*   `weather_data.csv`
*   `russian_production_calendar_2017_2025.csv`

**ВАЖНО:** Убедитесь, что форматы файлов соответствуют ожидаемым (как описано в `src/data_ingestion.py` или `src/preprocess.py`).

### Запуск пайплайна

Для запуска полного пайплайна (предобработка -> обучение -> прогнозирование) выполните:

```bash
python pipeline_runner.py

