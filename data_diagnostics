import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

# === КОНСТАНТЫ ===
CONSUMPTION_FILE = 'consumption_data.csv'
WEATHER_FILE = 'weather_data.csv'
CALENDAR_FILE = 'russian_production_calendar_2017_2025.csv'

def diagnose_consumption_data():
    """Диагностика данных по потреблению"""
    print("=== ДИАГНОСТИКА ДАННЫХ ПО ПОТРЕБЛЕНИЮ ===")
    
    try:
        df_cons = pd.read_csv(CONSUMPTION_FILE, sep=';')
        df_cons['datetime'] = pd.to_datetime(df_cons['date']) + pd.to_timedelta(df_cons['hour'], unit='h')
        df_cons = df_cons.sort_values('datetime')
        
        print(f"Общий размер данных: {len(df_cons)} строк")
        print(f"Период: {df_cons['datetime'].min()} - {df_cons['datetime'].max()}")
        
        # Пропуски
        print("\nПропуски в данных:")
        for col in df_cons.columns:
            missing = df_cons[col].isna().sum()
            if missing > 0:
                print(f"  {col}: {missing} ({missing/len(df_cons)*100:.2f}%)")
        
        # Плотность по годам
        df_cons['year'] = df_cons['datetime'].dt.year
        yearly_counts = df_cons.groupby('year').size()
        expected_per_year = 365 * 24
        
        print("\nПлотность данных по годам:")
        for year, count in yearly_counts.items():
            completeness = count / expected_per_year * 100
            print(f"  {year}: {count} записей ({completeness:.1f}% полноты)")
        
        return df_cons
        
    except Exception as e:
        print(f"Ошибка при диагностике потребления: {e}")
        return None

def diagnose_weather_data():
    """Диагностика данных по погоде с детальной проверкой"""
    print("\n=== ДИАГНОСТИКА ДАННЫХ ПО ПОГОДЕ ===")
    
    try:
        # Сначала проверим структуру файла
        with open(WEATHER_FILE, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        print(f"Всего строк в файле: {len(lines)}")
        
        # Найдем заголовок
        header_line = None
        data_start = 0
        for i, line in enumerate(lines):
            if line.strip().startswith('"Местное время'):
                header_line = line.strip()
                data_start = i + 1
                break
        
        print(f"Заголовок найден в строке {data_start}: {header_line}")
        
        # Посмотрим проблемные строки
        print("\nПроверка строк вокруг ошибки (1870-1880):")
        for i in range(1870, min(1881, len(lines))):
            line = lines[i].strip()
            fields = line.split(';')
            print(f"Строка {i+1} ({len(fields)} полей): {line[:100]}...")
        
        # Попробуем загрузить с обработкой ошибок
        print("\nПопытка загрузки с пропуском проблемных строк...")
        try:
            df_weather = pd.read_csv(
                WEATHER_FILE, 
                sep=';', 
                skiprows=data_start,
                encoding='utf-8',
                on_bad_lines='skip',
                low_memory=False
            )
            print(f"Успешно загружено: {len(df_weather)} строк")
        except Exception as e:
            print(f"Ошибка при загрузке: {e}")
            # Попробуем построчное чтение
            print("Попытка построчного чтения...")
            good_lines = []
            error_lines = []
            
            for i in range(data_start, len(lines)):
                try:
                    # Проверим строку
                    line = lines[i].strip()
                    if line and not line.startswith('#'):
                        fields = line.split(';')
                        if len(fields) >= 13:  # Минимальное количество полей
                            good_lines.append(line)
                        else:
                            error_lines.append((i+1, line, f"Мало полей: {len(fields)}"))
                except Exception as e:
                    error_lines.append((i+1, lines[i][:50], str(e)))
            
            print(f"Хороших строк: {len(good_lines)}")
            print(f"Проблемных строк: {len(error_lines)}")
            print("Примеры проблемных строк:")
            for line_num, line, error in error_lines[:5]:
                print(f"  Строка {line_num}: {error}")
            
            return None
        
        # Преобразование даты
        df_weather['datetime'] = pd.to_datetime(df_weather.iloc[:, 0], dayfirst=True)
        df_weather = df_weather.sort_values('datetime')
        
        print(f"Период погоды: {df_weather['datetime'].min()} - {df_weather['datetime'].max()}")
        
        # Анализ плотности
        df_weather['year'] = df_weather['datetime'].dt.year
        yearly_counts = df_weather.groupby('year').size()
        
        print("\nПлотность данных погоды по годам:")
        for year, count in yearly_counts.items():
            print(f"  {year}: {count} записей")
        
        return df_weather
        
    except Exception as e:
        print(f"Ошибка при диагностике погоды: {e}")
        return None

def diagnose_merge_process():
    """Диагностика процесса объединения данных"""
    print("\n=== ДИАГНОСТИКА ПРОЦЕССА ОБЪЕДИНЕНИЯ ===")
    
    # Загрузим данные
    df_cons = pd.read_csv(CONSUMPTION_FILE, sep=';')
    df_cons['datetime'] = pd.to_datetime(df_cons['date']) + pd.to_timedelta(df_cons['hour'], unit='h')
    
    print(f"Исходные данные потребления: {len(df_cons)} записей")
    
    # Проверим временные диапазоны
    print(f"Диапазон потребления: {df_cons['datetime'].min()} - {df_cons['datetime'].max()}")
    
    # Попробуем загрузить погоду
    try:
        with open(WEATHER_FILE, 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        data_start = 0
        for i, line in enumerate(lines):
            if line.strip().startswith('"Местное время'):
                data_start = i + 1
                break
        
        df_weather = pd.read_csv(
            WEATHER_FILE, 
            sep=';', 
            skiprows=data_start,
            encoding='utf-8',
            on_bad_lines='skip'
        )
        df_weather['datetime'] = pd.to_datetime(df_weather.iloc[:, 0], dayfirst=True)
        df_weather = df_weather.sort_values('datetime')
        
        print(f"Исходные данные погоды: {len(df_weather)} записей")
        print(f"Диапазон погоды: {df_weather['datetime'].min()} - {df_weather['datetime'].max()}")
        
        # Проверим пересечение периодов
        cons_start, cons_end = df_cons['datetime'].min(), df_cons['datetime'].max()
        weather_start, weather_end = df_weather['datetime'].min(), df_weather['datetime'].max()
        
        overlap_start = max(cons_start, weather_start)
        overlap_end = min(cons_end, weather_end)
        
        print(f"\nПериод пересечения: {overlap_start} - {overlap_end}")
        
        if overlap_start <= overlap_end:
            # Фильтруем данные по периоду пересечения
            df_cons_overlap = df_cons[
                (df_cons['datetime'] >= overlap_start) & 
                (df_cons['datetime'] <= overlap_end)
            ]
            
            df_weather_overlap = df_weather[
                (df_weather['datetime'] >= overlap_start) & 
                (df_weather['datetime'] <= overlap_end)
            ]
            
            print(f"Записи потребления в периоде пересечения: {len(df_cons_overlap)}")
            print(f"Записи погоды в периоде пересечения: {len(df_weather_overlap)}")
            
            # Попробуем объединение
            df_merged = pd.merge(df_cons_overlap, df_weather_overlap, 
                               left_on='datetime', right_on='datetime', how='left')
            
            print(f"Результат объединения: {len(df_merged)} записей")
            print(f"Пропуски в температуре после объединения: {df_merged['T'].isna().sum()}")
            
        else:
            print("Нет пересечения периодов!")
            
    except Exception as e:
        print(f"Ошибка при диагностике объединения: {e}")

def main():
    """Основная функция диагностики"""
    print("=== НАЧАЛО ДИАГНОСТИКИ ДАННЫХ ===")
    
    # Диагностика каждого компонента
    df_cons = diagnose_consumption_data()
    df_weather = diagnose_weather_data()
    diagnose_merge_process()
    
    print("\n=== ДИАГНОСТИКА ЗАВЕРШЕНА ===")

if __name__ == "__main__":
    main()
