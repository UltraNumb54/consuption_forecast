import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime

def diagnose_2019_problem():
    """Детальная диагностика проблемы с 2019 годом"""
    
    print("=== ДЕТАЛЬНАЯ ДИАГНОСТИКА 2019 ГОДА ===")
    
    # 1. Загрузим данные по потреблению за 2019
    df_cons = pd.read_csv('consumption_data.csv', sep=';')
    df_cons['datetime'] = pd.to_datetime(df_cons['date']) + pd.to_timedelta(df_cons['hour'], unit='h')
    df_cons_2019 = df_cons[df_cons['datetime'].dt.year == 2019].sort_values('datetime')
    
    print(f"Данные потребления 2019: {len(df_cons_2019)} записей")
    print(f"Период: {df_cons_2019['datetime'].min()} - {df_cons_2019['datetime'].max()}")
    
    # 2. Загрузим данные погоды за 2019
    with open('weather_data.csv', 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    data_start = 0
    for i, line in enumerate(lines):
        if line.strip().startswith('"Местное время'):
            data_start = i + 1
            break
    
    df_weather = pd.read_csv('weather_data.csv', sep=';', skiprows=data_start, 
                           encoding='utf-8', on_bad_lines='skip')
    df_weather['datetime'] = pd.to_datetime(df_weather.iloc[:, 0], dayfirst=True)
    df_weather_2019 = df_weather[df_weather['datetime'].dt.year == 2019].sort_values('datetime')
    
    print(f"Данные погоды 2019: {len(df_weather_2019)} записей")
    print(f"Период: {df_weather_2019['datetime'].min()} - {df_weather_2019['datetime'].max()}")
    
    # 3. Анализ плотности данных по месяцам
    print("\n=== АНАЛИЗ ПЛОТНОСТИ ПО МЕСЯЦАМ ===")
    
    # Потребление по месяцам
    df_cons_2019['month'] = df_cons_2019['datetime'].dt.month
    monthly_cons = df_cons_2019.groupby('month').size()
    
    # Погода по месяцам  
    df_weather_2019['month'] = df_weather_2019['datetime'].dt.month
    df_weather_2019['datetime_hour'] = df_weather_2019['datetime'].dt.floor('H')
    monthly_weather = df_weather_2019.groupby('month')['datetime_hour'].nunique()
    
    print("Плотность данных по месяцам 2019:")
    print("Месяц | Потребление | Погода | Совпадение")
    print("-" * 40)
    for month in range(1, 13):
        cons_count = monthly_cons.get(month, 0)
        weather_count = monthly_weather.get(month, 0)
        print(f"{month:2d}    | {cons_count:4d}       | {weather_count:4d}   | {cons_count-weather_count:+4d}")
    
    # 4. Поиск конкретных проблемных периодов
    print("\n=== ПОИСК ПРОБЛЕМНЫХ ПЕРИОДОВ ===")
    
    # Создадим полный временной ряд за 2019
    full_range = pd.date_range(start='2019-01-01', end='2019-12-31 23:00:00', freq='H')
    full_df = pd.DataFrame({'datetime': full_range})
    
    # Объединим с данными
    df_merged_check = pd.merge(full_df, df_cons_2019[['datetime', 'consumption']], on='datetime', how='left')
    df_merged_check = pd.merge(df_merged_check, df_weather_2019[['datetime_hour', 'T']], 
                              left_on='datetime', right_on='datetime_hour', how='left')
    
    # Найдем пропуски
    missing_consumption = df_merged_check[df_merged_check['consumption'].isna()]
    missing_weather = df_merged_check[df_merged_check['T'].isna()]
    
    print(f"Пропущенные часы потребления: {len(missing_consumption)}")
    print(f"Пропущенные часы погоды: {len(missing_weather)}")
    
    # 5. Визуализация плотности данных
    plt.figure(figsize=(15, 10))
    
    # График 1: Потребление по месяцам
    plt.subplot(2, 2, 1)
    monthly_cons.plot(kind='bar')
    plt.title('Потребление по месяцам 2019')
    plt.ylabel('Количество записей')
    plt.xticks(rotation=0)
    
    # График 2: Погода по месяцам
    plt.subplot(2, 2, 2)
    monthly_weather.plot(kind='bar', color='orange')
    plt.title('Погода по месяцам 2019')
    plt.ylabel('Количество записей')
    plt.xticks(rotation=0)
    
    # График 3: Совпадение данных
    plt.subplot(2, 2, 3)
    overlap = pd.merge(df_cons_2019[['datetime']], 
                      df_weather_2019[['datetime_hour']], 
                      left_on='datetime', right_on='datetime_hour', how='inner')
    overlap['month'] = overlap['datetime'].dt.month
    monthly_overlap = overlap.groupby('month').size()
    monthly_overlap.plot(kind='bar', color='green')
    plt.title('Совпадающие данные по месяцам')
    plt.ylabel('Количество совпадений')
    plt.xticks(rotation=0)
    
    # График 4: Временная линия пропусков
    plt.subplot(2, 2, 4)
    df_plot = df_merged_check.copy()
    df_plot['has_consumption'] = ~df_plot['consumption'].isna()
    df_plot['has_weather'] = ~df_plot['T'].isna()
    df_plot['both'] = df_plot['has_consumption'] & df_plot['has_weather']
    
    # Покажем недельные агрегаты для наглядности
    df_plot['week'] = df_plot['datetime'].dt.isocalendar().week
    weekly_stats = df_plot.groupby('week').agg({
        'has_consumption': 'mean',
        'has_weather': 'mean', 
        'both': 'mean'
    })
    
    weekly_stats.plot(kind='line')
    plt.title('Недельная полнота данных 2019')
    plt.ylabel('Доля полных записей')
    plt.xlabel('Неделя года')
    plt.legend(['Потребление', 'Погода', 'Оба'])
    plt.grid(True, alpha=0.3)
    
    plt.tight_layout()
    plt.savefig('diagnostics_2019.png', dpi=300, bbox_inches='tight')
    plt.show()
    
    # 6. Детальный анализ формата времени
    print("\n=== АНАЛИЗ ФОРМАТА ВРЕМЕНИ ===")
    
    # Проверим формат времени в погоде
    sample_weather = df_weather_2019.head(10)
    print("Примеры временных меток погоды:")
    for idx, row in sample_weather.iterrows():
        print(f"  {row['datetime']} - {type(row['datetime'])}")
    
    # Проверим формат времени в потреблении
    sample_cons = df_cons_2019.head(10)
    print("Примеры временных меток потребления:")
    for idx, row in sample_cons.iterrows():
        print(f"  {row['datetime']} - {type(row['datetime'])}")
    
    # Проверим точное совпадение времени
    print("\n=== ПРОВЕРКА ТОЧНОГО СОВПАДЕНИЯ ВРЕМЕНИ ===")
    
    # Округлим погоду до часов
    df_weather_2019['datetime_hour'] = df_weather_2019['datetime'].dt.floor('H')
    
    # Попробуем объединение
    test_merge = pd.merge(
        df_cons_2019[['datetime', 'consumption']].head(100),
        df_weather_2019[['datetime_hour', 'T']].head(1000),
        left_on='datetime', right_on='datetime_hour', how='left'
    )
    
    merge_success = len(test_merge[test_merge['T'].notna()])
    print(f"Успешных объединений в тестовой выборке: {merge_success}/100")
    
    return df_cons_2019, df_weather_2019

def main():
    try:
        diagnose_2019_problem()
        print("\n=== ДИАГНОСТИКА ЗАВЕРШЕНА ===")
        print("График сохранен в diagnostics_2019.png")
    except Exception as e:
        print(f"Ошибка при диагностике: {e}")

if __name__ == "__main__":
    main()
