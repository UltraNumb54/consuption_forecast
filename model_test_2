import pandas as pd
import numpy as np
from catboost import CatBoostRegressor
from sklearn.model_selection import TimeSeriesSplit
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error

# === КОНСТАНТЫ ===
TRAINING_DATA_FILE = 'filtered_training_data.csv'      # Отфильтрованные данные (без сентября 2025)
IMPROVED_MODEL_PATH = 'improved_energy_model.cbm'      # Путь для сохранения улучшенной модели
FEATURES_IMPORTANCE_PATH = 'improved_features_importance.png'
EVALUATION_PLOT_PATH = 'improved_model_evaluation.png'

# === ПАРАМЕТРЫ МОДЕЛИ ===
RANDOM_STATE = 42
TEST_SIZE = 0.2
TARGET_COLUMN = 'consumption'

def proper_time_series_training():
    """Правильное обучение с учетом временных рядов и уменьшением переобучения"""
    
    print("=== УЛУЧШЕННОЕ ОБУЧЕНИЕ С УМЕНЬШЕННЫМ РИСКОМ ПЕРЕОБУЧЕНИЯ ===")
    
    # Загрузка данных
    df = pd.read_csv(TRAINING_DATA_FILE)
    df['datetime'] = pd.to_datetime(df['datetime'])
    df = df.sort_values('datetime')
    
    print(f"Всего данных: {len(df)}")
    print(f"Период: {df['datetime'].min()} - {df['datetime'].max()}")
    
    # Подготовка признаков
    numerical_features = [
        'hour', 'dayofweek', 'month',
        'temperature', 'humidity', 'wind_speed',
        'consumption_lag_1', 'consumption_lag_2', 'consumption_lag_3',
        'consumption_lag_24', 'consumption_lag_48', 'consumption_lag_168',
        'consumption_rolling_mean_3', 'consumption_rolling_mean_6',
        'consumption_rolling_mean_12', 'consumption_rolling_mean_24',
        'consumption_rolling_std_3', 'consumption_rolling_std_6',
        'consumption_rolling_std_12', 'consumption_rolling_std_24'
    ]
    
    categorical_features = [
        'is_holiday', 'is_working_weekend', 'is_regular_weekend',
        'is_working_day', 'is_weekend_or_holiday', 'is_weekend'
    ]
    
    feature_columns = numerical_features + categorical_features
    target_column = TARGET_COLUMN
    
    # Удаление строк с пропусками
    df_clean = df[feature_columns + [target_column]].dropna()
    
    X = df_clean[feature_columns]
    y = df_clean[target_column]
    
    print(f"Данные после очистки: {len(X)}")
    
    # === ПРАВИЛЬНОЕ РАЗДЕЛЕНИЕ НА TRAIN/TEST ===
    # Используем последние 20% как тест (временная последовательность!)
    split_point = int(len(X) * (1 - TEST_SIZE))
    
    X_train = X.iloc[:split_point]
    X_test = X.iloc[split_point:]
    y_train = y.iloc[:split_point]
    y_test = y.iloc[split_point:]
    
    print(f"Train: {len(X_train)} записей")
    print(f"Test: {len(X_test)} записей")
    print(f"Период теста: {df.iloc[split_point]['datetime']} - {df.iloc[-1]['datetime']}")
    
    # === УЛУЧШЕННАЯ МОДЕЛЬ С ПРЕДОТВРАЩЕНИЕМ ПЕРЕОБУЧЕНИЯ ===
    model = CatBoostRegressor(
        iterations=500,              # Меньше итераций для предотвращения переобучения
        learning_rate=0.05,          # Меньше learning rate для стабильности
        depth=4,                     # Меньше глубина деревьев
        l2_leaf_reg=3,               # L2 регуляризация
        bootstrap_type='Bayesian',   # Байесовский бутстрэп для робастности
        bagging_temperature=0.2,     # Меньше бэггинга
        random_strength=0.2,         # Добавляем немного случайности
        loss_function='MAE',         # Целевая функция
        eval_metric='MAE',           # Метрика оценки
        random_seed=RANDOM_STATE,
        verbose=50,
        early_stopping_rounds=30,
        task_type='CPU'
    )
    
    print("Начало обучения...")
    model.fit(
        X_train, y_train,
        cat_features=categorical_features,
        eval_set=(X_test, y_test),
        use_best_model=True
    )
    
    # Предсказания
    y_pred_train = model.predict(X_train)
    y_pred_test = model.predict(X_test)
    
    # Оценка
    mae_train = mean_absolute_error(y_train, y_pred_train)
    mae_test = mean_absolute_error(y_test, y_pred_test)
    mape_test = mean_absolute_percentage_error(y_test, y_pred_test) * 100
    
    print(f"\n=== УЛУЧШЕННЫЕ РЕЗУЛЬТАТЫ ===")
    print(f"MAE на обучении: {mae_train:.3f}")
    print(f"MAE на тесте: {mae_test:.3f}")
    print(f"MAPE на тесте: {mape_test:.2f}%")
    print(f"Среднее потребление в тесте: {y_test.mean():.1f}")
    print(f"Точность (±2.5% от среднего): {mae_test < (y_test.mean() * 0.025)}")
    
    # Анализ переобучения
    overfitting_ratio = mae_test / mae_train if mae_train > 0 else float('inf')
    print(f"Коэффициент переобучения (MAE test/MAE train): {overfitting_ratio:.2f}")
    
    if overfitting_ratio > 2:
        print("⚠️  Высокий риск переобучения! Рекомендуется уменьшить сложность модели.")
    elif overfitting_ratio > 1.5:
        print("⚠️  Умеренный риск переобучения.")
    else:
        print("✅ Риск переобучения в норме.")
    
    # Важность признаков
    print(f"\n=== ТОП-10 САМЫХ ВАЖНЫХ ПРИЗНАКОВ ===")
    feature_importance = pd.DataFrame({
        'feature': X_train.columns,
        'importance': model.get_feature_importance()
    }).sort_values('importance', ascending=False)
    
    for i, row in feature_importance.head(10).iterrows():
        print(f"{i+1:2d}. {row['feature']}: {row['importance']:.2f}")
    
    # Сохранение модели
    model.save_model(IMPROVED_MODEL_PATH)
    print(f"\n✅ Улучшенная модель сохранена в {IMPROVED_MODEL_PATH}")
    
    return model

def cross_validate_time_series():
    """Кросс-валидация для временных рядов с уменьшением переобучения"""
    print("\n=== КРОСС-ВАЛИДАЦИЯ ВРЕМЕННЫХ РЯДОВ ===")
    
    df = pd.read_csv(TRAINING_DATA_FILE)
    df['datetime'] = pd.to_datetime(df['datetime'])
    df = df.sort_values('datetime')
    
    # TimeSeriesSplit для временных рядов (последовательное разделение)
    tscv = TimeSeriesSplit(n_splits=5)
    
    # Подготовка данных
    numerical_features = [
        'hour', 'dayofweek', 'month',
        'temperature', 'humidity', 'wind_speed',
        'consumption_lag_1', 'consumption_lag_2', 'consumption_lag_3',
        'consumption_lag_24', 'consumption_lag_48', 'consumption_lag_168',
        'consumption_rolling_mean_3', 'consumption_rolling_mean_6',
        'consumption_rolling_mean_12', 'consumption_rolling_mean_24',
        'consumption_rolling_std_3', 'consumption_rolling_std_6',
        'consumption_rolling_std_12', 'consumption_rolling_std_24'
    ]
    
    categorical_features = [
        'is_holiday', 'is_working_weekend', 'is_regular_weekend',
        'is_working_day', 'is_weekend_or_holiday', 'is_weekend'
    ]
    
    feature_columns = numerical_features + categorical_features
    target_column = TARGET_COLUMN
    
    df_clean = df[feature_columns + [target_column]].dropna()
    X = df_clean[feature_columns]
    y = df_clean[target_column]
    
    # Кросс-валидация
    mae_scores = []
    mape_scores = []
    
    print("Выполнение кросс-валидации...")
    for fold, (train_idx, val_idx) in enumerate(tscv.split(X)):
        print(f"Fold {fold + 1}/5")
        
        X_train_fold, X_val_fold = X.iloc[train_idx], X.iloc[val_idx]
        y_train_fold, y_val_fold = y.iloc[train_idx], y.iloc[val_idx]
        
        # Упрощенная модель для кросс-валидации
        model = CatBoostRegressor(
            iterations=300,
            learning_rate=0.05,
            depth=4,
            l2_leaf_reg=3,
            loss_function='MAE',
            eval_metric='MAE',
            random_seed=RANDOM_STATE,
            verbose=0
        )
        
        model.fit(
            X_train_fold, y_train_fold,
            cat_features=categorical_features,
            eval_set=(X_val_fold, y_val_fold),
            use_best_model=True,
            early_stopping_rounds=20
        )
        
        y_pred = model.predict(X_val_fold)
        mae = mean_absolute_error(y_val_fold, y_pred)
        mape = mean_absolute_percentage_error(y_val_fold, y_pred) * 100
        
        mae_scores.append(mae)
        mape_scores.append(mape)
        
        print(f"  MAE: {mae:.3f}, MAPE: {mape:.2f}%")
    
    print(f"\n=== РЕЗУЛЬТАТЫ КРОСС-ВАЛИДАЦИИ ===")
    print(f"Средний MAE: {np.mean(mae_scores):.3f} ± {np.std(mae_scores):.3f}")
    print(f"Средний MAPE: {np.mean(mape_scores):.2f}% ± {np.std(mape_scores):.2f}%")
    print(f"Диапазон MAE: {min(mae_scores):.3f} - {max(mae_scores):.3f}")
    
    return mae_scores, mape_scores


def main():
    """Основная функция обучения"""
    print("=== УЛУЧШЕННОЕ ОБУЧЕНИЕ МОДЕЛИ ===")
    
    try:
        
        # Улучшенное обучение
        print("\nУЛУЧШЕННОЕ ОБУЧЕНИЕ")
        model = proper_time_series_training()
        
        # Кросс-валидация
        print("\nКРОСС-ВАЛИДАЦИЯ")
        mae_scores, mape_scores = cross_validate_time_series()
        
        print(f"\nОБУЧЕНИЕ ЗАВЕРШЕНО!")
        print(f"Финальная модель: {IMPROVED_MODEL_PATH}")
        print(f"Средняя точность по CV: MAE={np.mean(mae_scores):.3f}, MAPE={np.mean(mape_scores):.2f}%")
        
    except Exception as e:
        print(f"Ошибка при обучении: {e}")

if __name__ == "__main__":
    main()
