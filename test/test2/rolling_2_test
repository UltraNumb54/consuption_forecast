# improved_rolling_retrain.py
import pandas as pd
import numpy as np
from catboost import CatBoostRegressor
import matplotlib.pyplot as plt
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
from datetime import datetime, timedelta
import os
import warnings
warnings.filterwarnings('ignore')

OUTPUT_DIR = './improved_rolling_retrain/'
os.makedirs(OUTPUT_DIR, exist_ok=True)

def create_features_full(df):
    """Создаёт признаки на полном непрерывном датасете"""
    df = df.copy().sort_values('datetime')
    df['hour'] = df['datetime'].dt.hour
    df['hour_sin'] = np.sin(2 * np.pi * df['hour'] / 24)
    df['hour_cos'] = np.cos(2 * np.pi * df['hour'] / 24)
    df['dayofweek'] = df['datetime'].dt.dayofweek
    df['month'] = df['datetime'].dt.month
    df['week_of_year'] = df['datetime'].dt.isocalendar().week
    season = df['month'] % 12 // 3 + 1
    for s, name in [(1, 'winter'), (2, 'spring'), (3, 'summer'), (4, 'autumn')]:
        df[f'is_{name}'] = (season == s).astype(int)
    df['is_weekend'] = df['dayofweek'].isin([5, 6]).astype(int)
    
    # Календарные признаки — предполагаем, что они уже в df
    calendar_cols = ['is_holiday', 'is_working_weekend', 'is_regular_weekend', 
                     'is_working_day', 'is_weekend_or_holiday']
    for col in calendar_cols:
        if col not in df.columns:
            df[col] = 0
    
    # Лаги и окна
    lag_hours = [1, 2, 3, 24, 48, 72, 120, 168, 336, 720]
    for lag in lag_hours:
        df[f'consumption_lag_{lag}'] = df['consumption'].shift(lag)
    
    windows = [3, 6, 12, 24, 168, 720]
    for w in windows:
        df[f'consumption_rolling_mean_{w}'] = df['consumption'].rolling(w, min_periods=1).mean()
        df[f'consumption_rolling_std_{w}'] = df['consumption'].rolling(w, min_periods=1).std()
    
    spans = [6, 12, 24, 48]
    for s in spans:
        df[f'consumption_ewm_mean_{s}'] = df['consumption'].ewm(span=s).mean()
    
    return df

def train_and_predict_month(df_history, df_month_actual, month_name):
    """Обучает модель и предсказывает на один месяц"""
    # Объединяем историю и месяц для расчёта признаков
    df_combined = pd.concat([df_history, df_month_actual], ignore_index=True)
    df_combined = df_combined.sort_values('datetime')
    
    # Рассчитываем признаки на всём
    df_features = create_features_full(df_combined)
    
    # Берём только обучающую часть (без месяца прогноза)
    df_train = df_features[df_features['datetime'] < df_month_actual['datetime'].min()]
    df_train = df_train.dropna()
    
    if len(df_train) < 500:
        return None, None
    
    # Готовим X_train, y_train
    feature_cols = [col for col in df_train.columns if col not in 
                   ['datetime', 'date_only', 'year', 'consumption', 'date_for_merge']]
    X_train = df_train[feature_cols]
    y_train = df_train['consumption']
    
    # Категориальные признаки
    cat_features = [col for col in X_train.columns if 'is_' in col or col in 
                   ['hour', 'dayofweek', 'month', 'week_of_year']]
    
    # Обучение
    model = CatBoostRegressor(
        iterations=500,
        learning_rate=0.05,
        depth=6,
        loss_function='MAPE',
        cat_features=cat_features,
        verbose=False,
        random_seed=42
    )
    model.fit(X_train, y_train)
    
    # Предсказание: берём признаки только для месяца
    df_pred = df_features[df_features['datetime'].isin(df_month_actual['datetime'])]
    X_pred = df_pred[feature_cols]
    predictions = model.predict(X_pred)
    
    return predictions, df_pred

def main():
    df_full = pd.read_csv('enhanced_filtered_full_data.csv')
    df_full['datetime'] = pd.to_datetime(df_full['datetime'])
    
    # История: 2022 и 2024
    df_history = df_full[df_full['year'].isin([2022, 2024])].copy()
    df_history = df_history.sort_values('datetime')
    
    all_results = []
    
    for month in range(1, 13):
        start = datetime(2025, month, 1)
        end = datetime(2025, month+1, 1) - timedelta(seconds=1) if month < 12 else datetime(2025, 12, 31, 23, 59, 59)
        
        df_month = df_full[(df_full['datetime'] >= start) & (df_full['datetime'] <= end)].copy()
        if len(df_month) == 0:
            continue
        
        print(f"Обработка {start.strftime('%B %Y')}...")
        preds, df_pred = train_and_predict_month(df_history, df_month, start.strftime('%B'))
        
        if preds is not None:
            results = pd.DataFrame({
                'datetime': df_month['datetime'].values,
                'actual': df_month['consumption'].values,
                'predicted': preds,
                'month': month
            })
            all_results.append(results)
            
            # График для месяца
            plt.figure(figsize=(15, 6))
            plt.plot(results['datetime'], results['actual'], 'b-', label='Реальное')
            plt.plot(results['datetime'], results['predicted'], 'r--', label='Предсказанное')
            plt.title(f'Прогноз на {start.strftime("%B %Y")}')
            plt.legend()
            plt.grid(True, alpha=0.3)
            plt.savefig(f'{OUTPUT_DIR}forecast_{month:02d}_{start.strftime("%B")}.png', dpi=150)
            plt.close()
            
            # Обновляем историю
            df_history = pd.concat([df_history, df_month], ignore_index=True)
    
    if all_results:
        final_df = pd.concat(all_results, ignore_index=True)
        final_df.to_csv(f'{OUTPUT_DIR}all_predictions.csv', index=False)
        print("✅ Все прогнозы сохранены")

if __name__ == "__main__":
    main()
