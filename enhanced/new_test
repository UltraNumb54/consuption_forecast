# simulation_test_2025.py
import pandas as pd
import numpy as np
from catboost import CatBoostRegressor
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# === КОНСТАНТЫ ===
MODEL_PATH = 'enhanced_energy_model.cbm'
CONSUMPTION_FILE = 'consumption_data.csv'
WEATHER_FILE = 'weather_data.csv'
CALENDAR_FILE = 'russian_production_calendar_2017_2025.csv'

SIM_START = datetime(2025, 1, 1)
SIM_END = datetime(2025, 12, 31)

# === ЗАГРУЗКА СЫРЫХ ДАННЫХ ===
def load_raw_data():
    print("Загрузка сырых данных...")
    # 1. Потребление
    df_cons = pd.read_csv(CONSUMPTION_FILE, sep=';')
    df_cons['datetime'] = pd.to_datetime(df_cons['date']) + pd.to_timedelta(df_cons['hour'], unit='h')
    df_cons = df_cons[['datetime', 'consumption', 'temperature']].dropna()
    df_cons.set_index('datetime', inplace=True)
    df_cons.sort_index(inplace=True)

    # 2. Погода (влажность, ветер)
    with open(WEATHER_FILE, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    header_line = None
    for i, line in enumerate(lines):
        if line.strip().startswith('"Местное время'):
            data_start = i + 1
            break
    df_weather = pd.read_csv(WEATHER_FILE, sep=';', skiprows=data_start, on_bad_lines='skip', encoding='utf-8')
    if len(df_weather.columns) >= 13:
        df_weather = df_weather.iloc[:, :13]
        df_weather.columns = ['datetime', 'T', 'P0', 'P', 'U', 'DD', 'Ff', 'ff10', 'WW', 'WW2', 'clouds', 'VV', 'Td']
    else:
        # fallback
        pass
    df_weather['datetime'] = pd.to_datetime(df_weather['datetime'], dayfirst=True)
    df_weather = df_weather[['datetime', 'U', 'Ff']].rename(columns={'U': 'humidity', 'Ff': 'wind_speed'})
    df_weather.set_index('datetime', inplace=True)
    df_weather = df_weather.resample('H').mean().interpolate(method='time')
    
    # 3. Календарь
    df_cal = pd.read_csv(CALENDAR_FILE)
    df_cal['date'] = pd.to_datetime(df_cal['date']).dt.date
    df_cal.set_index('date', inplace=True)

    print(f"Потребление: {df_cons.index.min()} – {df_cons.index.max()}")
    print(f"Погода: {df_weather.index.min()} – {df_weather.index.max()}")
    return df_cons, df_weather, df_cal

# === ФУНКЦИЯ СОЗДАНИЯ ПРИЗНАКОВ НА ЛЕТУ ===
def build_features_for_datetime(target_dt, hist_cons, df_weather, df_cal):
    """Создаёт признаки для одного часа target_dt на основе истории hist_cons (сырой Series)"""
    features = {}

    # Временные признаки
    features['hour'] = target_dt.hour
    features['hour_sin'] = np.sin(2 * np.pi * target_dt.hour / 24)
    features['hour_cos'] = np.cos(2 * np.pi * target_dt.hour / 24)
    features['dayofweek'] = target_dt.weekday()
    features['month'] = target_dt.month
    features['week_of_year'] = target_dt.isocalendar()[1]
    features['is_winter'] = int(target_dt.month in [12, 1, 2])
    features['is_spring'] = int(target_dt.month in [3, 4, 5])
    features['is_summer'] = int(target_dt.month in [6, 7, 8])
    features['is_autumn'] = int(target_dt.month in [9, 10, 11])
    features['is_weekend'] = int(features['dayofweek'] in [5, 6])

    # Календарь
    target_date = target_dt.date()
    day_type = df_cal.loc[target_date, 'day_type'] if target_date in df_cal.index else 'working day'
    features['is_holiday'] = int(day_type == 'non-working holiday')
    features['is_working_weekend'] = int(day_type == 'working weekend')
    features['is_regular_weekend'] = int(day_type == 'weekend')
    features['is_working_day'] = int(day_type == 'working day')
    features['is_weekend_or_holiday'] = int(day_type in ['weekend', 'non-working holiday'])

    # Погода (берём ближайшее значение, если нет точного)
    weather_val = None
    if target_dt in df_weather.index:
        weather_val = df_weather.loc[target_dt]
    else:
        past_w = df_weather[df_weather.index <= target_dt]
        if not past_w.empty:
            weather_val = past_w.iloc[-1]
    if weather_val is not None:
        features['humidity'] = weather_val.get('humidity', np.nan)
        features['wind_speed'] = weather_val.get('wind_speed', np.nan)
    else:
        features['humidity'] = np.nan
        features['wind_speed'] = np.nan

    # Температура — из consumption_data.csv (НЕ из consumption!)
    temp_val = np.nan
    if target_dt in df_cons.index:
        temp_val = df_cons.loc[target_dt, 'temperature']
    else:
        # Ищем ближайшую прошлую температуру
        past_t = df_cons[df_cons.index <= target_dt]
        if not past_t.empty:
            temp_val = past_t['temperature'].iloc[-1]
    features['temperature'] = temp_val

    # === ЛАГИ И СКОЛЬЗЯЩИЕ — ТОЛЬКО ИЗ ИСТОРИИ ДО target_dt ===
    hist_for_features = hist_cons[hist_cons.index < target_dt]
    if hist_for_features.empty:
        # Заполняем NaN
        lag_hours = [1, 2, 3, 24, 48, 72, 120, 168]
        windows = [3, 6, 12, 24, 720]
        spans = [3, 6, 12, 24]
        for lag in lag_hours:
            features[f'consumption_lag_{lag}'] = np.nan
        for w in windows:
            features[f'consumption_rolling_mean_{w}'] = np.nan
            features[f'consumption_rolling_std_{w}'] = np.nan
        for s in spans:
            features[f'consumption_ewm_mean_{s}'] = np.nan
    else:
        # Лаги
        lag_hours = [1, 2, 3, 24, 48, 72, 120, 168]
        for lag in lag_hours:
            lag_time = target_dt - timedelta(hours=lag)
            if lag_time in hist_for_features.index:
                features[f'consumption_lag_{lag}'] = hist_for_features.loc[lag_time, 'consumption']
            else:
                features[f'consumption_lag_{lag}'] = np.nan

        # Rolling
        windows = [3, 6, 12, 24, 720]
        for w in windows:
            window_start = target_dt - timedelta(hours=w)
            window_data = hist_for_features[(hist_for_features.index >= window_start)]
            if len(window_data) > 0:
                features[f'consumption_rolling_mean_{w}'] = window_data['consumption'].mean()
                features[f'consumption_rolling_std_{w}'] = window_data['consumption'].std()
            else:
                features[f'consumption_rolling_mean_{w}'] = np.nan
                features[f'consumption_rolling_std_{w}'] = np.nan

        # EWM
        spans = [3, 6, 12, 24]
        for s in spans:
            window_start = target_dt - timedelta(hours=s)
            window_data = hist_for_features[(hist_for_features.index >= window_start)]
            if len(window_data) > 0:
                features[f'consumption_ewm_mean_{s}'] = window_data['consumption'].ewm(span=s).mean().iloc[-1]
            else:
                features[f'consumption_ewm_mean_{s}'] = np.nan

    # --- ДЕБАГ ---
    if target_dt.hour == 0 and target_dt.day == 1 and target_dt.month == 1:
        print(f"[DEBUG] {target_dt}:")
        print(f"  consumption_lag_24 = {features.get('consumption_lag_24')}")
        print(f"  consumption_rolling_mean_24 = {features.get('consumption_rolling_mean_24')}")
        print(f"  temperature = {features.get('temperature')}")
        print(f"  humidity = {features.get('humidity')}")
        print("  ---")

    return features

# === ОСНОВНАЯ СИМУЛЯЦИЯ ===
def simulate_2025():
    df_cons, df_weather, df_cal = load_raw_data()
    model = CatBoostRegressor()
    model.load_model(MODEL_PATH)
    feature_names = model.feature_names_
    print(f"Модель обучалась на {len(feature_names)} признаках: {feature_names[:5]}...")

    # История начинается с данных до 1 января 2025
    hist_cons = df_cons[df_cons.index < SIM_START]  # DataFrame, а не Series!

    results_1d = []
    results_3d = []

    current_day = SIM_START
    while current_day <= SIM_END:
        print(f"\nПрогноз на {current_day.strftime('%Y-%m-%d')}...")

        # --- Прогноз на 1 день ---
        hours_1d = [current_day + timedelta(hours=h) for h in range(24)]
        X_1d = []
        for dt in hours_1d:
            feat = build_features_for_datetime(dt, hist_cons, df_weather, df_cal)
            X_1d.append(feat)
        X_1d = pd.DataFrame(X_1d)
        X_1d = X_1d.reindex(columns=feature_names, fill_value=np.nan)
        pred_1d = model.predict(X_1d)

        # Реальность
        real_1d = df_cons.loc[hours_1d, 'consumption']
        if len(real_1d) != 24:
            print("  Пропуск: не хватает реальных данных")
            current_day += timedelta(days=1)
            continue

        mae = mean_absolute_error(real_1d, pred_1d)
        mape = mean_absolute_percentage_error(real_1d, pred_1d) * 100
        results_1d.append({'date': current_day, 'mae': mae, 'mape': mape})

        # --- Прогноз на 3 дня ---
        hours_3d = [current_day + timedelta(hours=h) for h in range(72)]
        X_3d = []
        for dt in hours_3d:
            feat = build_features_for_datetime(dt, hist_cons, df_weather, df_cal)
            X_3d.append(feat)
        X_3d = pd.DataFrame(X_3d)
        X_3d = X_3d.reindex(columns=feature_names, fill_value=np.nan)
        pred_3d = model.predict(X_3d)

        real_3d = df_cons.loc[hours_3d, 'consumption']
        if len(real_3d) != 72:
            print("  Пропуск 3d: не хватает данных")
        else:
            mae3 = mean_absolute_error(real_3d, pred_3d)
            mape3 = mean_absolute_percentage_error(real_3d, pred_3d) * 100
            results_3d.append({'date': current_day, 'mae': mae3, 'mape': mape3})

        # --- Обновляем историю: добавляем реальные данные за current_day ---
        new_data = df_cons[(df_cons.index >= current_day) & (df_cons.index < current_day + timedelta(days=1))]
        if not new_data.empty:
            hist_cons = pd.concat([hist_cons, new_data])

        current_day += timedelta(days=1)

    # === ВЫВОД ПО МЕСЯЦАМ ===
    df1 = pd.DataFrame(results_1d)
    df1['month'] = df1['date'].dt.month
    df3 = pd.DataFrame(results_3d)
    df3['month'] = df3['date'].dt.month

    print("\n=== РЕЗУЛЬТАТЫ ПО МЕСЯЦАМ (1 день) ===")
    print(df1.groupby('month')[['mae', 'mape']].mean().round(3))

    print("\n=== РЕЗУЛЬТАТЫ ПО МЕСЯЦАМ (3 дня) ===")
    print(df3.groupby('month')[['mae', 'mape']].mean().round(3))

    df1.to_csv('sim_1day_2025.csv', index=False)
    df3.to_csv('sim_3day_2025.csv', index=False)
    print("\nРезультаты сохранены.")

if __name__ == "__main__":
    simulate_2025()
