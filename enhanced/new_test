# corrected_simulation_test_2025.py
import pandas as pd
import numpy as np
from catboost import CatBoostRegressor
from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
from datetime import datetime, timedelta
import warnings
warnings.filterwarnings('ignore')

# === КОНСТАНТЫ ===
MODEL_PATH = 'enhanced_energy_model.cbm'
PROCESSED_TRAINING_FILE = 'enhanced_filtered_training_data.csv'  # Используем предобработанные данные!

def corrected_simulation():
    """Исправленная симуляция, соответствующая процессу обучения"""
    
    # Загружаем ПРЕДОБРАБОТАННЫЕ данные (как при обучении)
    df = pd.read_csv(PROCESSED_TRAINING_FILE)
    df['datetime'] = pd.to_datetime(df['datetime'])
    df = df.sort_values('datetime')
    
    # Загружаем модель и получаем признаки
    model = CatBoostRegressor()
    model.load_model(MODEL_PATH)
    feature_names = model.feature_names_
    
    print(f"Модель использует {len(feature_names)} признаков")
    
    # Разделяем на тренировочную часть и "будущее" для симуляции
    split_date = datetime(2024, 12, 1)  # Все что после - симулируем прогноз
    train_data = df[df['datetime'] < split_date]
    test_period = df[df['datetime'] >= split_date]
    
    results = []
    
    # Симулируем прогноз на 3 дня вперед для каждого дня в тестовом периоде
    for current_date in test_period['datetime'].unique():
        current_date = pd.to_datetime(current_date)
        
        # Данные ДО текущей даты (история)
        historical_data = df[df['datetime'] < current_date]
        
        # Целевые даты для прогноза (следующие 72 часа)
        forecast_dates = pd.date_range(
            start=current_date, 
            periods=72, 
            freq='H'
        )
        
        # Фильтруем только те даты, которые есть в реальных данных
        actual_data = test_period[test_period['datetime'].isin(forecast_dates)]
        
        if len(actual_data) < 24:  # Минимум 1 день данных для оценки
            continue
            
        # Берем признаки для прогнозируемых дат из ПРЕДОБРАБОТАННЫХ данных
        # Это имитирует идеальный прогноз признаков (температура, погода и т.д.)
        X_forecast = actual_data[feature_names]
        y_actual = actual_data['consumption']
        
        # Прогноз
        y_pred = model.predict(X_forecast)
        
        # Оценка для 1 дня и 3 дней
        for days_ahead in [1, 3]:
            hours = 24 * days_ahead
            if len(y_actual) >= hours:
                y_act_subset = y_actual[:hours]
                y_pred_subset = y_pred[:hours]
                
                mae = mean_absolute_error(y_act_subset, y_pred_subset)
                mape = mean_absolute_percentage_error(y_act_subset, y_pred_subset) * 100
                
                results.append({
                    'date': current_date,
                    'days_ahead': days_ahead,
                    'mae': mae,
                    'mape': mape,
                    'data_points': len(y_act_subset)
                })
    
    # Анализ результатов
    results_df = pd.DataFrame(results)
    
    print("\n=== РЕЗУЛЬТАТЫ ИСПРАВЛЕННОЙ СИМУЛЯЦИИ ===")
    for days in [1, 3]:
        subset = results_df[results_df['days_ahead'] == days]
        if len(subset) > 0:
            print(f"\nПрогноз на {days} день(дней):")
            print(f"Средний MAE: {subset['mae'].mean():.3f}")
            print(f"Средний MAPE: {subset['mape'].mean():.2f}%")
            print(f"Количество прогнозов: {len(subset)}")
    
    return results_df

def analyze_discrepancies():
    """Анализ различий между подходами"""
    
    # 1. Сравнение признаков
    df_processed = pd.read_csv(PROCESSED_TRAINING_FILE)
    model = CatBoostRegressor()
    model.load_model(MODEL_PATH)
    
    print("=== АНАЛИЗ РАЗЛИЧИЙ ===")
    print(f"Признаки в обученной модели: {len(model.feature_names_)}")
    print("Примеры признаков:", model.feature_names_[:10])
    
    # 2. Проверка распределения целевой переменной
    print(f"\nРаспределение consumption в обучающих данных:")
    print(df_processed['consumption'].describe())
    
    # 3. Проверка на наличие пропусков
    print(f"\nПропуски в обучающих данных:")
    print(df_processed[model.feature_names_].isnull().sum().sum())

if __name__ == "__main__":
    # Анализ различий
    analyze_discrepancies()
    
    # Запуск исправленной симуляции
    print("\n" + "="*50)
    results = corrected_simulation()
    
    # Сохранение результатов
    results.to_csv('corrected_simulation_results.csv', index=False)
    print("\nРезультаты сохранены в corrected_simulation_results.csv")
