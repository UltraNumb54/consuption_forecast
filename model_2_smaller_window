import pandas as pd
import numpy as np
from catboost import CatBoostRegressor
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# === КОНСТАНТЫ ===
MODEL_PATH = 'improved_energy_model.cbm'
PROCESSED_DATA_FILE = 'processed_energy_data.csv'
TEST_START_DATE = '2025-09-08'
TEST_DAYS = 3
HISTORICAL_WINDOW_DAYS = 14  # Достаточно 14 дней

def load_model():
    """Загрузка обученной модели"""
    model = CatBoostRegressor()
    model.load_model(MODEL_PATH)
    return model

def get_model_feature_info():
    """Получение информации о признаках модели"""
    # Загрузим модель и создадим тестовый датасет для получения структуры
    model = load_model()
    
    # Определяем структуру признаков как при обучении
    numerical_features = [
        'hour', 'dayofweek', 'month',
        'temperature', 'humidity', 'wind_speed',
        'consumption_lag_1', 'consumption_lag_2', 'consumption_lag_3',
        'consumption_lag_24', 'consumption_lag_48', 'consumption_lag_168',
        'consumption_rolling_mean_3', 'consumption_rolling_mean_6',
        'consumption_rolling_mean_12', 'consumption_rolling_mean_24',
        'consumption_rolling_std_3', 'consumption_rolling_std_6',
        'consumption_rolling_std_12', 'consumption_rolling_std_24'
    ]
    
    categorical_features = [
        'is_holiday', 'is_working_weekend', 'is_regular_weekend',
        'is_working_day', 'is_weekend_or_holiday', 'is_weekend'
    ]
    
    return numerical_features, categorical_features

def prepare_features_for_prediction(df_historical, prediction_datetime, weather_data):
    """Подготовка признаков для одного предсказания"""
    
    # Базовые временные признаки (целые числа для категориальных)
    features = {
        'hour': int(prediction_datetime.hour),
        'dayofweek': int(prediction_datetime.weekday()),
        'month': int(prediction_datetime.month),
    }
    
    # Погодные данные (вещественные числа)
    features.update({
        'temperature': float(weather_data.get('temperature', 10.0)),
        'humidity': float(weather_data.get('humidity', 70.0)),
        'wind_speed': float(weather_data.get('wind_speed', 3.0)),
    })
    
    # Лаговые признаки
    for lag in [1, 2, 3, 24, 48, 168]:
        lag_time = prediction_datetime - timedelta(hours=lag)
        lag_data = df_historical[df_historical['datetime'] == lag_time]
        if len(lag_data) > 0:
            features[f'consumption_lag_{lag}'] = float(lag_data['consumption'].iloc[0])
        else:
            features[f'consumption_lag_{lag}'] = float(df_historical['consumption'].median())
    
    # Скользящие признаки
    for window in [3, 6, 12, 24]:
        recent_data = df_historical[
            df_historical['datetime'] < prediction_datetime
        ].tail(window)
        
        if len(recent_data) >= min(3, window):
            mean_val = float(recent_data['consumption'].mean())
            std_val = float(recent_data['consumption'].std())
            features[f'consumption_rolling_mean_{window}'] = mean_val
            features[f'consumption_rolling_std_{window}'] = std_val
        else:
            mean_val = float(df_historical['consumption'].mean())
            std_val = float(df_historical['consumption'].std())
            features[f'consumption_rolling_mean_{window}'] = mean_val
            features[f'consumption_rolling_std_{window}'] = std_val
    
    # Календарные признаки (целые числа 0 или 1)
    features.update({
        'is_holiday': int(0),
        'is_working_weekend': int(0),
        'is_regular_weekend': int(prediction_datetime.weekday() in [5, 6]),
        'is_working_day': int(prediction_datetime.weekday() not in [5, 6]),
        'is_weekend_or_holiday': int(prediction_datetime.weekday() in [5, 6]),
        'is_weekend': int(prediction_datetime.weekday() in [5, 6]),
    })
    
    return features

def september_prediction_fixed():
    """Исправленное предсказание для сентября 2025"""
    
    print("=== ИСПРАВЛЕННОЕ ПРЕДСКАЗАНИЕ ДЛЯ СЕНТЯБРЯ 2025 ===")
    
    # Получаем информацию о признаках
    numerical_features, categorical_features = get_model_feature_info()
    all_features = numerical_features + categorical_features
    
    print(f"Числовые признаки: {len(numerical_features)}")
    print(f"Категориальные признаки: {len(categorical_features)}")
    
    # Загрузка модели
    model = load_model()
    print("Модель загружена")
    
    # Загрузка исторических данных
    df_historical = pd.read_csv(PROCESSED_DATA_FILE)
    df_historical['datetime'] = pd.to_datetime(df_historical['datetime'])
    print(f"Исторические данные: {len(df_historical)} записей")
    
    # Определяем период тестирования
    test_start = datetime.strptime(TEST_START_DATE, '%Y-%m-%d')
    test_end = test_start + timedelta(days=TEST_DAYS)
    
    print(f"Тестирование с {test_start} по {test_end}")
    
    # Фильтруем данные
    max_history_date = test_start - timedelta(days=HISTORICAL_WINDOW_DAYS)
    training_data = df_historical[
        (df_historical['datetime'] < test_start) & 
        (df_historical['datetime'] >= max_history_date)
    ]
    
    test_data = df_historical[
        (df_historical['datetime'] >= test_start) & 
        (df_historical['datetime'] < test_end)
    ]
    
    print(f"Обучающие данные: {len(training_data)} записей ({HISTORICAL_WINDOW_DAYS} дней)")
    print(f"Тестовые данные: {len(test_data)} записей")
    
    if len(test_data) == 0:
        print("Нет тестовых данных!")
        return
    
    # Подготовка предсказаний
    predictions = []
    actual_values = []
    prediction_times = []
    
    # Создаем расширенную историю для пошагового предсказания
    extended_history = training_data.copy()
    
    print("Начало предсказаний...")
    
    for idx, row in test_data.iterrows():
        prediction_time = row['datetime']
        actual_consumption = row['consumption']
        
        # Погодные данные из реальных исторических данных
        weather_data = {
            'temperature': row.get('temperature', 10.0),
            'humidity': row.get('humidity', 70.0),
            'wind_speed': row.get('wind_speed', 3.0),
        }
        
        # Подготовка признаков
        features = prepare_features_for_prediction(extended_history, prediction_time, weather_data)
        
        # Создание DataFrame с правильным порядком колонок
        features_dict = {col: features.get(col, 0) for col in all_features}
        features_df = pd.DataFrame([features_dict])
        
        # Убеждаемся в правильных типах данных
        for col in features_df.columns:
            if col in categorical_features:
                features_df[col] = features_df[col].astype(int)
            else:
                features_df[col] = pd.to_numeric(features_df[col], errors='coerce').fillna(0.0)
        
        # Выполнение предсказания
        try:
            prediction = model.predict(features_df)[0]
            predictions.append(float(prediction))
            actual_values.append(float(actual_consumption))
            prediction_times.append(prediction_time)
            
            print(f"{prediction_time}: предсказано {prediction:.1f}, реально {actual_consumption:.1f}")
            
            # Добавляем предсказание в историю для следующих шагов
            new_row = {
                'datetime': prediction_time,
                'consumption': float(prediction),
                'hour': int(prediction_time.hour),
                'dayofweek': int(prediction_time.weekday()),
                'month': int(prediction_time.month),
                'temperature': float(weather_data['temperature'])
            }
            
            # Копируем другие доступные колонки
            for col in extended_history.columns:
                if col not in new_row and col in row and pd.notna(row[col]):
                    new_row[col] = row[col]
            
            new_row_df = pd.DataFrame([new_row])
            extended_history = pd.concat([extended_history, new_row_df], ignore_index=True)
            
        except Exception as e:
            print(f"Ошибка при предсказании {prediction_time}: {e}")
            print(f"Признаки: {list(features_df.columns)}")
            print(f"Типы: {features_df.dtypes}")
            continue
    
    # Оценка качества
    if len(predictions) > 0:
        from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
        
        mae = mean_absolute_error(actual_values, predictions)
        mape = mean_absolute_percentage_error(actual_values, predictions) * 100
        
        print(f"\nРезультаты:")
        print(f"Количество предсказаний: {len(predictions)}")
        print(f"MAE: {mae:.3f}")
        print(f"MAPE: {mape:.2f}%")
        print(f"Среднее потребление: {np.mean(actual_values):.1f} МВт")
        
        # Визуализация
        if len(predictions) > 1:
            plt.figure(figsize=(15, 8))
            
            plt.subplot(2, 1, 1)
            plt.plot(prediction_times, actual_values, 'b-', label='Реальное', linewidth=2)
            plt.plot(prediction_times, predictions, 'r--', label='Предсказанное', linewidth=2)
            plt.title(f'Предсказания vs Реальные значения (MAE={mae:.3f})')
            plt.ylabel('Потребление (МВт)')
            plt.legend()
            plt.grid(True, alpha=0.3)
            
            plt.subplot(2, 1, 2)
            errors = np.abs(np.array(actual_values) - np.array(predictions))
            plt.plot(prediction_times, errors, 'g-', alpha=0.7)
            plt.title('Абсолютные ошибки')
            plt.ylabel('Ошибка (МВт)')
            plt.xlabel('Время')
            plt.grid(True, alpha=0.3)
            
            plt.tight_layout()
            plt.savefig('september_prediction_results.png', dpi=300, bbox_inches='tight')
            plt.show()
        
        # Сохранение результатов
        results_df = pd.DataFrame({
            'datetime': prediction_times,
            'actual_consumption': actual_values,
            'predicted_consumption': predictions,
            'absolute_error': np.abs(np.array(actual_values) - np.array(predictions))
        })
        results_df.to_csv('september_prediction_detailed.csv', index=False)
        print("Результаты сохранены в september_prediction_detailed.csv")
        
    else:
        print("Не удалось выполнить ни одного предсказания!")

if __name__ == "__main__":
    september_prediction_fixed()
