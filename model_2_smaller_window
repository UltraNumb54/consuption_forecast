import pandas as pd
import numpy as np
from catboost import CatBoostRegressor
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# === КОНСТАНТЫ ===
MODEL_PATH = 'improved_energy_model.cbm'
PROCESSED_DATA_FILE = 'processed_energy_data.csv'
TEST_START_DATE = '2025-09-08'
TEST_DAYS = 3
HISTORICAL_WINDOW_DAYS = 14

def load_model():
    """Загрузка обученной модели"""
    model = CatBoostRegressor()
    model.load_model(MODEL_PATH)
    return model

def prepare_features_for_prediction(df_historical, prediction_datetime, weather_data):
    """Подготовка признаков для одного предсказания"""
    
    # Создаем словарь признаков
    features = {}
    
    # Базовые временные признаки (целые числа)
    features['hour'] = prediction_datetime.hour
    features['dayofweek'] = prediction_datetime.weekday()
    features['month'] = prediction_datetime.month
    
    # Погодные данные (вещественные числа)
    features['temperature'] = weather_data.get('temperature', 10.0)
    features['humidity'] = weather_data.get('humidity', 70.0)
    features['wind_speed'] = weather_data.get('wind_speed', 3.0)
    
    # Лаговые признаки
    for lag in [1, 2, 3, 24, 48, 168]:
        lag_time = prediction_datetime - timedelta(hours=lag)
        lag_data = df_historical[df_historical['datetime'] == lag_time]
        if len(lag_data) > 0:
            features[f'consumption_lag_{lag}'] = float(lag_data['consumption'].iloc[0])
        else:
            features[f'consumption_lag_{lag}'] = float(df_historical['consumption'].median())
    
    # Скользящие признаки
    for window in [3, 6, 12, 24]:
        recent_data = df_historical[
            df_historical['datetime'] < prediction_datetime
        ].tail(window)
        
        if len(recent_data) >= min(3, window):
            features[f'consumption_rolling_mean_{window}'] = float(recent_data['consumption'].mean())
            features[f'consumption_rolling_std_{window}'] = float(recent_data['consumption'].std())
        else:
            features[f'consumption_rolling_mean_{window}'] = float(df_historical['consumption'].mean())
            features[f'consumption_rolling_std_{window}'] = float(df_historical['consumption'].std())
    
    # Календарные признаки (целые числа 0 или 1)
    is_weekend = 1 if prediction_datetime.weekday() in [5, 6] else 0
    is_working_day = 1 if prediction_datetime.weekday() not in [5, 6] else 0
    
    features['is_holiday'] = 0
    features['is_working_weekend'] = 0
    features['is_regular_weekend'] = is_weekend
    features['is_working_day'] = is_working_day
    features['is_weekend_or_holiday'] = is_weekend
    features['is_weekend'] = is_weekend
    
    return features

def september_prediction_clean():
    """Очищенное предсказание для сентября 2025"""
    
    print("=== ПРЕДСКАЗАНИЕ ДЛЯ СЕНТЯБРЯ 2025 ===")
    
    # Загрузка модели
    model = load_model()
    print("Модель загружена")
    
    # Загрузка исторических данных
    df_historical = pd.read_csv(PROCESSED_DATA_FILE)
    df_historical['datetime'] = pd.to_datetime(df_historical['datetime'])
    print(f"Исторические данные: {len(df_historical)} записей")
    
    # Определяем период тестирования
    test_start = datetime.strptime(TEST_START_DATE, '%Y-%m-%d')
    test_end = test_start + timedelta(days=TEST_DAYS)
    
    print(f"Тестирование с {test_start} по {test_end}")
    
    # Фильтруем данные
    max_history_date = test_start - timedelta(days=HISTORICAL_WINDOW_DAYS)
    training_data = df_historical[
        (df_historical['datetime'] < test_start) & 
        (df_historical['datetime'] >= max_history_date)
    ]
    
    test_data = df_historical[
        (df_historical['datetime'] >= test_start) & 
        (df_historical['datetime'] < test_end)
    ]
    
    print(f"Обучающие данные: {len(training_data)} записей ({HISTORICAL_WINDOW_DAYS} дней)")
    print(f"Тестовые данные: {len(test_data)} записей")
    
    if len(test_data) == 0:
        print("Нет тестовых данных!")
        return
    
    # Подготовка предсказаний
    predictions = []
    actual_values = []
    prediction_times = []
    
    # Создаем расширенную историю для пошагового предсказания
    extended_history = training_data.copy()
    
    print("Начало предсказаний...")
    
    for idx, row in test_data.iterrows():
        prediction_time = row['datetime']
        actual_consumption = row['consumption']
        
        # Погодные данные
        weather_data = {
            'temperature': row.get('temperature', 10.0),
            'humidity': row.get('humidity', 70.0),
            'wind_speed': row.get('wind_speed', 3.0),
        }
        
        # Подготовка признаков
        features = prepare_features_for_prediction(extended_history, prediction_time, weather_data)
        
        # Создание DataFrame
        features_df = pd.DataFrame([features])
        
        # Приведение типов данных
        categorical_features = ['hour', 'dayofweek', 'month', 'is_holiday', 'is_working_weekend', 
                              'is_regular_weekend', 'is_working_day', 'is_weekend_or_holiday', 'is_weekend']
        
        for col in features_df.columns:
            if col in categorical_features:
                features_df[col] = features_df[col].astype(int)
            else:
                features_df[col] = pd.to_numeric(features_df[col], errors='coerce').fillna(0.0)
        
        # Выполнение предсказания
        try:
            prediction = model.predict(features_df)[0]
            predictions.append(float(prediction))
            actual_values.append(float(actual_consumption))
            prediction_times.append(prediction_time)
            
            print(f"{prediction_time}: предсказано {prediction:.1f}, реально {actual_consumption:.1f}")
            
            # Добавляем предсказание в историю
            new_row = {
                'datetime': prediction_time,
                'consumption': float(prediction),
                'hour': prediction_time.hour,
                'dayofweek': prediction_time.weekday(),
                'month': prediction_time.month,
                'temperature': weather_data['temperature']
            }
            
            # Копируем другие колонки
            for col in extended_history.columns:
                if col not in new_row and col in row and pd.notna(row[col]):
                    new_row[col] = row[col]
            
            new_row_df = pd.DataFrame([new_row])
            extended_history = pd.concat([extended_history, new_row_df], ignore_index=True)
            
        except Exception as e:
            print(f"Ошибка при предсказании {prediction_time}: {e}")
            continue
    
    # Оценка качества
    if len(predictions) > 0:
        from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error
        
        mae = mean_absolute_error(actual_values, predictions)
        mape = mean_absolute_percentage_error(actual_values, predictions) * 100
        
        print(f"\nРезультаты:")
        print(f"Количество предсказаний: {len(predictions)}")
        print(f"MAE: {mae:.3f}")
        print(f"MAPE: {mape:.2f}%")
        print(f"Среднее потребление: {np.mean(actual_values):.1f} МВт")
        
        # Сохранение результатов
        results_df = pd.DataFrame({
            'datetime': prediction_times,
            'actual_consumption': actual_values,
            'predicted_consumption': predictions,
            'absolute_error': np.abs(np.array(actual_values) - np.array(predictions))
        })
        results_df.to_csv('september_prediction_detailed.csv', index=False)
        print("Результаты сохранены в september_prediction_detailed.csv")
        
    else:
        print("Не удалось выполнить ни одного предсказания!")

if __name__ == "__main__":
    september_prediction_clean()
